<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DLMM Position Simulator (dlmm.ts 準拠)</title>
<link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
<style>
  body {
    font-family: 'M PLUS Rounded 1c', sans-serif;
    margin: 20px auto;
    max-width: 900px;
    background: linear-gradient(135deg, #fff0f5, #e6f3ff);
    background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path fill="%23ffccdd" opacity="0.1" d="M10 2.5a1.5 1.5 0 110 3 1.5 1.5 0 010-3zm0 12a1.5 1.5 0 110 3 1.5 1.5 0 010-3zM2.5 10a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm12 0a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0z"/></svg>');
    color: #4a4a4a;
    line-height: 1.6;
    padding: 10px;
  }
  h1 {
    font-size: 28px;
    margin-bottom: 25px;
    text-align: center;
    color: #ff6b9b;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
  }
  form {
    display: grid;
    grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
    gap: 12px 20px;
    background: #fff;
    padding: 20px;
    border-radius: 20px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    border: 3px solid #ffd1e3;
  }
  label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 16px;
    color: #ff6b9b;
    font-weight: 600;
  }
  input {
    flex: 1;
    margin-left: 10px;
    padding: 8px 12px;
    border: 2px solid #ffccdd;
    border-radius: 12px;
    background: #fff5f8;
    font-family: 'M PLUS Rounded 1c', sans-serif;
    font-size: 15px;
    transition: border-color 0.3s ease;
  }
  input:focus {
    border-color: #ff6b9b;
    outline: none;
  }
  input[type="number"]::-webkit-inner-spin-button,
  input[type="number"]::-webkit-outer-spin-button {
    opacity: 1;
  }
  .container {
    position: relative;
    padding: 20px;
    border-radius: 20px;
    background: rgba(255, 255, 255, 0.95);
  }
  .container::before {
    content: '🌟';
    position: absolute;
    top: -15px;
    left: 15px;
    font-size: 28px;
    color: #ff6b9b;
  }
  .container::after {
    content: '💗';
    position: absolute;
    bottom: -15px;
    right: 15px;
    font-size: 28px;
    color: #ff6b9b;
  }
  /* 結果表のスタイル */
  .result-table {
    margin-top: 20px;
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    background: #fff;
    border-radius: 15px;
    overflow: hidden;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    border: 3px solid #ffd1e3;
    table-layout: fixed;
  }
  .result-table th, .result-table td {
    padding: 10px 8px;
    text-align: center;
    font-size: 14px;
    color: #4a4a4a;
    border-bottom: 1px solid #ffd1e3;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .result-table th {
    background: linear-gradient(135deg, #ffccdd, #ffe6f0);
    color: #ff6b9b;
    font-weight: 700;
  }
  .result-table th:not(:first-child) {
    border-left: 1px solid #ffd1e3;
  }
  .result-table td:not(:first-child) {
    border-left: 1px solid #ffd1e3;
  }
  .result-table tr:hover {
    background: #fff5f8;
  }
  .result-table td:first-child {
    text-align: left;
    font-weight: 600;
    width: 30%;
  }
  .result-table th:not(:first-child), .result-table td:not(:first-child) {
    width: 23.33%;
  }
  .result-table td:first-child::before {
    margin-right: 8px;
    font-size: 16px;
  }
  .result-table tr:nth-child(1) td:first-child::before { content: '💰'; }
  .result-table tr:nth-child(2) td:first-child::before { content: '📊'; }
  .result-table tr:nth-child(3) td:first-child::before { content: '📈'; }
  .result-table tr:nth-child(4) td:first-child::before { content: '💸'; }
  .result-table tr:nth-child(5) td:first-child::before { content: '📉'; }
  .result-table tr:nth-child(6) td:first-child::before { content: '🪙'; }
  .result-table tr:nth-child(7) td:first-child::before { content: '💵'; }
  .result-table tr:nth-child(8) td:first-child::before { content: '📋'; }
  .result-table tr:nth-child(9) td:first-child::before { content: '🟦'; }
  .result-table tr:nth-child(10) td:first-child::before { content: '🟪'; }
  /* レスポンシブ対応 */
  .table-wrapper {
    overflow-x: auto;
    margin-top: 20px;
  }
  /* シナリオごとの色分け */
  .result-table th.lower { background: linear-gradient(135deg, #d4f0ff, #e6f3ff); }
  .result-table th.current { background: linear-gradient(135deg, #ffccdd, #ffe6f0); }
  .result-table th.upper { background: linear-gradient(135deg, #e6ffe6, #d4ffd4); }
  .result-table td.lower { background: #f0faff; }
  .result-table td.current { background: #fff5f8; }
  .result-table td.upper { background: #f0fff0; }
  /* ラジオボタンのスタイル */
  .radio-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-left: 10px;
    align-items: center;
  }
  .radio-label {
    display: inline-flex;
    align-items: center;
    padding: 8px 12px;
    border: 2px solid #ffccdd;
    border-radius: 12px;
    background: #fff5f8;
    cursor: pointer;
    font-size: 15px;
    color: #ff6b9b;
    transition: all 0.2s ease;
    min-width: 80px;
    justify-content: center;
  }
  .radio-label:hover {
    background: #ffe6f0;
    border-color: #ff8ab5;
    transform: scale(1.05);
  }
  .radio-label input[type="radio"] {
    display: none;
  }
  .radio-label input[type="radio"]:checked + span {
    background: linear-gradient(135deg, #ff9cc2, #ff6b9b);
    color: #fff;
    border-radius: 10px;
    padding: 6px 10px;
    box-shadow: 0 2px 8px rgba(255, 107, 155, 0.3);
  }
  .radio-label span {
    padding: 4px 8px;
    border-radius: 8px;
    transition: all 0.2s ease;
  }
  .radio-label span::before {
    content: '✨';
    margin-right: 5px;
  }
  /* モバイル対応 */
  @media (max-width: 600px) {
    form {
      grid-template-columns: minmax(0, 1fr);
      gap: 10px;
    }
    .result-table th, .result-table td {
      font-size: 12px;
      padding: 8px;
    }
    .radio-group {
      flex-direction: column;
      align-items: flex-start;
    }
    .radio-label {
      width: 100%;
      justify-content: center;
    }
    h1 {
      font-size: 24px;
    }
    input, .radio-label {
      font-size: 14px;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <h1>🌟 DLMM Position Simulator（dlmm.ts 準拠）💗</h1>

    <form class="grid">
      <label>binStep <input id="binStep" type="number" value="10" step="1" min="1"></label>
      <label>初期価格 <input id="initialPrice" type="number" value="200" step="0.0001"></label>
      <label>トークンA(ex.SOL) <input id="baseAmount" type="number" value="2.5" step="0.0001"></label>
      <label>トークンB(ex.USDC) <input id="quoteAmount" type="number" value="500" step="0.0001"></label>
      <label>下限価格 <input id="lowerPrice" type="number" value="180" step="0.0001"></label>
      <label>上限価格 <input id="upperPrice" type="number" value="220" step="0.0001"></label>
      <label>戦略型
        <div class="radio-group">
          <label class="radio-label">
            <input type="radio" name="strategy" value="spot" checked>
            <span>Spot</span>
          </label>
          <label class="radio-label">
            <input type="radio" name="strategy" value="bid-ask">
            <span>Bid-Ask</span>
          </label>
          <label class="radio-label">
            <input type="radio" name="strategy" value="curve">
            <span>Curve</span>
          </label>
        </div>
      </label>
      <label>現在価格 <input id="currentPrice" type="number" value="190" step="0.0001"></label>
    </form>

    <div class="table-wrapper">
      <table id="output" class="result-table" style="display: none;">
        <thead>
          <tr>
            <th>項目</th>
            <th class="lower">下限価格</th>
            <th class="current">現在価格</th>
            <th class="upper">上限価格</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>初期TVL</td><td id="initialValue_lower" class="lower"></td><td id="initialValue_current" class="current"></td><td id="initialValue_upper" class="upper"></td></tr>
          <tr><td>現在TVL</td><td id="currentValue_lower" class="lower"></td><td id="currentValue_current" class="current"></td><td id="currentValue_upper" class="upper"></td></tr>
          <tr><td>TVL Change</td><td id="valueChangePct_lower" class="lower"></td><td id="valueChangePct_current" class="current"></td><td id="valueChangePct_upper" class="upper"></td></tr>
          <tr><td>Profit/Loss</td><td id="profitLoss_lower" class="lower"></td><td id="profitLoss_current" class="current"></td><td id="profitLoss_upper" class="upper"></td></tr>
          <tr><td>価格変動</td><td id="priceChangePct_lower" class="lower"></td><td id="priceChangePct_current" class="current"></td><td id="priceChangePct_upper" class="upper"></td></tr>
          <tr><td>A Tokens(ex.SOL)</td><td id="totalBase_lower" class="lower"></td><td id="totalBase_current" class="current"></td><td id="totalBase_upper" class="upper"></td></tr>
          <tr><td>B Tokens(ex.USDC)</td><td id="totalQuote_lower" class="lower"></td><td id="totalQuote_current" class="current"></td><td id="totalQuote_upper" class="upper"></td></tr>
          <tr><td>Total Bins</td><td id="totalBins_lower" class="lower"></td><td id="totalBins_current" class="current"></td><td id="totalBins_upper" class="upper"></td></tr>
          <tr><td>Base Bins</td><td id="baseBins_lower" class="lower"></td><td id="baseBins_current" class="current"></td><td id="baseBins_upper" class="upper"></td></tr>
          <tr><td>Quote Bins</td><td id="quoteBins_lower" class="lower"></td><td id="quoteBins_current" class="current"></td><td id="quoteBins_upper" class="upper"></td></tr>
        </tbody>
      </table>
    </div>
  </div>

<script>
const CENTER_ID = 262144;

// --- helpers (dlmm.ts equivalence) ---
function getPriceFromId(id, binStep) {
  const basis = 1 + binStep / 10000;
  return basis ** (id - CENTER_ID);
}
function getIdFromPrice(price, binStep) {
  if (price <= 0 || binStep <= 0) return 0;
  const basis = 1 + binStep / 10000;
  return Math.floor(Math.log(price) / Math.log(basis)) + CENTER_ID;
}

// --- core logic (faithful port of your Python) ---
function getInitialBins(params) {
  const { binStep, initialPrice, baseAmount, quoteAmount, lowerPrice, upperPrice, strategy } = params;

  if (lowerPrice <= 0 || upperPrice <= lowerPrice || binStep <= 0 || initialPrice <= 0) {
    return [];
  }

  const minId = getIdFromPrice(lowerPrice, binStep);
  const maxId = getIdFromPrice(upperPrice, binStep);
  const initialPriceId = getIdFromPrice(initialPrice, binStep);

  const bins = [];
  const quoteBins = [];
  const baseBins = [];
  for (let id = minId; id <= maxId; id++) {
    const price = getPriceFromId(id, binStep);
    bins.push({
      id,
      price,
      initialTokenType: 'base',
      initialAmount: 0,
      initialValueInQuote: 0,
      displayValue: 0,
      currentTokenType: 'base',
      currentAmount: 0,
      currentValueInQuote: 0
    });
    if (id <= initialPriceId) quoteBins.push({ id, price });
    if (id > initialPriceId) baseBins.push({ id, price });
  }

  // Distribute Quote
  if (quoteAmount > 0 && quoteBins.length > 0) {
    let totalWeight = 0;
    const weights = new Map();
    for (const qb of quoteBins) {
      const dist = initialPriceId - qb.id;
      let weight;
      if (strategy === 'curve') {
        const maxDist = initialPriceId - minId;
        weight = maxDist > 0 ? (maxDist - dist) : 1;
      } else if (strategy === 'bid-ask') {
        weight = dist;
      } else {
        weight = 1;
      }
      totalWeight += weight;
      weights.set(qb.id, weight);
    }
    if (totalWeight > 0) {
      for (const b of bins) {
        if (weights.has(b.id)) {
          const amount = quoteAmount * (weights.get(b.id) / totalWeight);
          b.initialTokenType = 'quote';
          b.initialAmount = amount;
          b.initialValueInQuote = amount;
        }
      }
    }
  }

  // Distribute Base (by value)
  if (baseAmount > 0 && baseBins.length > 0) {
    let totalValueWeight = 0;
    const totalValue = baseAmount * initialPrice;
    const weights = new Map();
    for (const bb of baseBins) {
      const dist = bb.id - initialPriceId;
      let weight;
      if (strategy === 'curve') {
        const maxDist = maxId - initialPriceId;
        weight = maxDist > 0 ? (maxDist - dist) : 1;
      } else if (strategy === 'bid-ask') {
        weight = dist;
      } else {
        weight = 1;
      }
      const valueWeight = weight * bb.price;
      totalValueWeight += valueWeight;
      weights.set(bb.id, { weight, price: bb.price });
    }
    if (totalValueWeight > 0) {
      for (const b of bins) {
        if (weights.has(b.id)) {
          const { weight, price } = weights.get(b.id);
          const targetValue = totalValue * ((weight * price) / totalValueWeight);
          const amount = targetValue / price;
          b.initialTokenType = 'base';
          b.initialAmount = amount;
          b.initialValueInQuote = targetValue;
        }
      }
    }
  }

  // Normalization (floating point correction)
  const calculatedBaseSum = bins.reduce((s, b) => s + (b.initialTokenType === 'base' ? b.initialAmount : 0), 0);
  const calculatedQuoteSum = bins.reduce((s, b) => s + (b.initialTokenType === 'quote' ? b.initialAmount : 0), 0);

  if (baseAmount > 0 && calculatedBaseSum > 0) {
    const baseCorrectionFactor = baseAmount / calculatedBaseSum;
    for (const b of bins) {
      if (b.initialTokenType === 'base') {
        b.initialAmount *= baseCorrectionFactor;
        b.initialValueInQuote = b.initialAmount * initialPrice;
      }
    }
  }
  if (quoteAmount > 0 && calculatedQuoteSum > 0) {
    const quoteCorrectionFactor = quoteAmount / calculatedQuoteSum;
    for (const b of bins) {
      if (b.initialTokenType === 'quote') {
        b.initialAmount *= quoteCorrectionFactor;
        b.initialValueInQuote = b.initialAmount;
      }
    }
  }

  for (const b of bins) {
    b.displayValue = b.initialValueInQuote;
  }

  bins.sort((a, b) => a.price - b.price);
  return bins;
}

function runSimulation(initialBins, currentPrice, initialPrice) {
  if (!initialBins || initialBins.length === 0) {
    return { simulatedBins: [], analysis: { totalValueInQuote: 0, totalBase: 0, totalQuote: 0, totalBins: 0, baseBins: 0, quoteBins: 0 } };
  }

  const simulatedBins = initialBins.map(b => ({ ...b }));
  let totalBase = 0, totalQuote = 0, baseBins = 0, quoteBins = 0;

  for (const bin of simulatedBins) {
    if (bin.initialAmount <= 0) {
      bin.currentAmount = 0;
      bin.currentValueInQuote = 0;
      bin.currentTokenType = bin.initialTokenType;
      bin.displayValue = 0;
      continue;
    }

    if (currentPrice > bin.price) {
      bin.currentTokenType = 'quote';
      bin.currentAmount = (bin.initialTokenType === 'base')
        ? (bin.initialAmount * bin.price)
        : bin.initialAmount;
      bin.currentValueInQuote = bin.currentAmount;
      if (bin.currentAmount > 1e-12) { totalQuote += bin.currentAmount; quoteBins++; }
    } else {
      bin.currentTokenType = 'base';
      bin.currentAmount = (bin.initialTokenType === 'quote')
        ? (bin.initialAmount / bin.price)
        : bin.initialAmount;
      bin.currentValueInQuote = bin.currentAmount * currentPrice;
      if (bin.currentAmount > 1e-12) { totalBase += bin.currentAmount; baseBins++; }
    }
  }

  const totalBins = initialBins.filter(b => b.initialAmount > 1e-12).length;
  const totalValueInQuote = totalQuote + (totalBase * currentPrice);

  return {
    simulatedBins,
    analysis: { totalValueInQuote, totalBase, totalQuote, totalBins, baseBins, quoteBins }
  };
}

function positionAnalysis(params, currentPrice) {
  const bins = getInitialBins(params);
  const { analysis } = runSimulation(bins, currentPrice, params.initialPrice);

  const initialValue = params.baseAmount * params.initialPrice + params.quoteAmount;
  const currentValue = analysis.totalValueInQuote;

  const valueChangePct = initialValue > 0 ? ((currentValue - initialValue) / initialValue) * 100 : 0;
  const profitLoss = currentValue - initialValue;
  const priceChangePct = params.initialPrice > 0 ? ((currentPrice - params.initialPrice) / params.initialPrice) * 100 : 0;

  return {
    initialValue,
    currentValue,
    valueChangePct,
    profitLoss,
    priceChangePct,
    totalBase: analysis.totalBase,
    totalQuote: analysis.totalQuote,
    totalBins: analysis.totalBins,
    baseBins: analysis.baseBins,
    quoteBins: analysis.quoteBins
  };
}

function simulate() {
  const params = {
    binStep: Math.floor(+document.getElementById('binStep').value || 10), // 整数に
    initialPrice: +document.getElementById('initialPrice').value || 200,
    baseAmount: +document.getElementById('baseAmount').value || 2.5,
    quoteAmount: +document.getElementById('quoteAmount').value || 500,
    lowerPrice: +document.getElementById('lowerPrice').value || 180,
    upperPrice: +document.getElementById('upperPrice').value || 220,
    strategy: document.querySelector('input[name="strategy"]:checked').value
  };
  const currentPrice = +document.getElementById('currentPrice').value || 190;

  // 入力値の検証
  if (params.lowerPrice <= 0 || params.upperPrice <= params.lowerPrice || params.binStep <= 0 || params.initialPrice <= 0) {
    document.getElementById('output').style.display = 'none';
    return;
  }

  // 3つのシナリオ（下限、現在、上限）でシミュレーション
  const lowerResult = positionAnalysis(params, params.lowerPrice);
  const currentResult = positionAnalysis(params, currentPrice);
  const upperResult = positionAnalysis(params, params.upperPrice);

  // テーブルに値を設定
  document.getElementById('initialValue_lower').textContent = lowerResult.initialValue.toFixed(4);
  document.getElementById('initialValue_current').textContent = currentResult.initialValue.toFixed(4);
  document.getElementById('initialValue_upper').textContent = upperResult.initialValue.toFixed(4);

  document.getElementById('currentValue_lower').textContent = lowerResult.currentValue.toFixed(4);
  document.getElementById('currentValue_current').textContent = currentResult.currentValue.toFixed(4);
  document.getElementById('currentValue_upper').textContent = upperResult.currentValue.toFixed(4);

  document.getElementById('valueChangePct_lower').textContent = lowerResult.valueChangePct.toFixed(2) + '%';
  document.getElementById('valueChangePct_current').textContent = currentResult.valueChangePct.toFixed(2) + '%';
  document.getElementById('valueChangePct_upper').textContent = upperResult.valueChangePct.toFixed(2) + '%';

  document.getElementById('profitLoss_lower').textContent = lowerResult.profitLoss.toFixed(4);
  document.getElementById('profitLoss_current').textContent = currentResult.profitLoss.toFixed(4);
  document.getElementById('profitLoss_upper').textContent = upperResult.profitLoss.toFixed(4);

  document.getElementById('priceChangePct_lower').textContent = lowerResult.priceChangePct.toFixed(2) + '%';
  document.getElementById('priceChangePct_current').textContent = currentResult.priceChangePct.toFixed(2) + '%';
  document.getElementById('priceChangePct_upper').textContent = upperResult.priceChangePct.toFixed(2) + '%';

  document.getElementById('totalBase_lower').textContent = lowerResult.totalBase.toFixed(4);
  document.getElementById('totalBase_current').textContent = currentResult.totalBase.toFixed(4);
  document.getElementById('totalBase_upper').textContent = lowerResult.totalBase.toFixed(4);

  document.getElementById('totalQuote_lower').textContent = lowerResult.totalQuote.toFixed(4);
  document.getElementById('totalQuote_current').textContent = currentResult.totalQuote.toFixed(4);
  document.getElementById('totalQuote_upper').textContent = upperResult.totalQuote.toFixed(4);

  document.getElementById('totalBins_lower').textContent = lowerResult.totalBins;
  document.getElementById('totalBins_current').textContent = currentResult.totalBins;
  document.getElementById('totalBins_upper').textContent = upperResult.totalBins;

  document.getElementById('baseBins_lower').textContent = lowerResult.baseBins;
  document.getElementById('baseBins_current').textContent = currentResult.baseBins;
  document.getElementById('baseBins_upper').textContent = upperResult.baseBins;

  document.getElementById('quoteBins_lower').textContent = lowerResult.quoteBins;
  document.getElementById('quoteBins_current').textContent = currentResult.quoteBins;
  document.getElementById('quoteBins_upper').textContent = upperResult.quoteBins;

  document.getElementById('output').style.display = 'table';
}

// 自動更新のためのイベントリスナー
document.addEventListener('DOMContentLoaded', () => {
  const inputs = ['binStep', 'initialPrice', 'baseAmount', 'quoteAmount', 'lowerPrice', 'upperPrice', 'currentPrice'];
  inputs.forEach(id => {
    const input = document.getElementById(id);
    if (id === 'binStep') {
      input.addEventListener('input', () => {
        input.value = Math.floor(input.value); // 整数に制限
        simulate();
      });
    } else {
      input.addEventListener('input', simulate);
    }
  });
  document.querySelectorAll('input[name="strategy"]').forEach(radio => {
    radio.addEventListener('change', simulate);
  });
  simulate(); // 初期表示
});
</script>
</body>
</html>
